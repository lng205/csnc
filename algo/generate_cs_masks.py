#!/usr/bin/env python3
"""
Generate real cyclic-shift XOR masks for CS encoder/decoder from Vandermonde matrices.

Outputs a SystemVerilog header (.svh) with:
- localparam logic [L-1:0] CS_ENC_COEFF [K][M]
- localparam logic [L-1:0] CS_DEC_COEFF [M][K]  (for a fixed erasure set -> available columns)

Usage:
  python algo/generate_cs_masks.py --L 11 --M 3 --K 5 \
    --avail 0 1 2 \
    --out verilog/generated/cs_coeff_L11_M3_K5_avail_0_1_2.svh

Note: Masks encode GF(2^(L-1)) elements in bit form (LSB = rotate by 0),
      parity bit (MSB) is 0 by construction; hardware may flip masks internally
      to reduce shift count just like algo does.
"""
from __future__ import annotations
import argparse
from pathlib import Path
import numpy as np

from vandermonde import Van


def to_lbit_mask(x: int, L: int) -> int:
    # Place GF element (L-1 bits) in lower bits; top parity bit left as 0
    return int(x) & ((1 << (L - 1)) - 1)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--L", type=int, required=True)
    ap.add_argument("--M", type=int, required=True)
    ap.add_argument("--K", type=int, required=True)
    ap.add_argument("--avail", type=int, nargs='+', required=True, help="Available column indices of length M, e.g., 0 1 2")
    ap.add_argument("--out", type=str, required=True)
    args = ap.parse_args()

    L, M, K = args.L, args.M, args.K
    avail = list(map(int, args.avail))
    assert len(avail) == M and all(0 <= a < K for a in avail) and len(set(avail)) == M

    van = Van(m=M, k=K, order=L - 1)

    # Encoder masks: K x M (each output as combination of M inputs)
    enc = np.asarray(van.M, dtype=int)  # shape M x K (rows: inputs, cols: outputs)
    enc_kxm = enc.T  # K x M

    # Decoder masks for fixed erasure -> only columns in 'avail' are used
    dec_mxm = np.asarray(van.invert(avail), dtype=int)  # M x M
    dec_mxk = np.zeros((M, K), dtype=int)
    for j_idx, col in enumerate(avail):
        dec_mxk[:, col] = dec_mxm[:, j_idx]

    # Render SV localparams
    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    def row_to_sv(row):
        items = ", ".join(f"{L}'b{to_lbit_mask(int(v), L):0{L}b}" for v in row)
        return f"'{{ {items} }}"

    lines = []
    lines.append(f"// Auto-generated by generate_cs_masks.py (L={L}, M={M}, K={K}, avail={avail})")
    lines.append(f"localparam int CS_L = {L};")
    lines.append(f"localparam int CS_M = {M};")
    lines.append(f"localparam int CS_K = {K};")
    lines.append("")
    lines.append("localparam logic [CS_L-1:0] CS_ENC_COEFF [CS_K][CS_M] = '{")
    for r in range(K):
        row = enc_kxm[r, :]
        comma = "," if r < K - 1 else ""
        lines.append(f"  {row_to_sv(row)}{comma}")
    lines.append("};")
    lines.append("")
    lines.append("localparam logic [CS_L-1:0] CS_DEC_COEFF [CS_M][CS_K] = '{")
    for r in range(M):
        row = dec_mxk[r, :]
        comma = "," if r < M - 1 else ""
        lines.append(f"  {row_to_sv(row)}{comma}")
    lines.append("};")
    lines.append("")

    out_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()
